# coding: utf-8

"""
    Mozart platform API

    API for interacting with the Mozart platform.

    The version of the OpenAPI document: 0.2.0
    Contact: support@bang-olufsen.dk
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    StrictBool,
    StrictStr,
    field_validator,
)
from typing import Any, ClassVar, Dict, List, Optional
from mozart_api.models.action import Action
from typing import Optional, Set
from typing_extensions import Self


class RemoteMenuItemProperties(BaseModel):
    """
    RemoteMenuItemProperties
    """  # noqa: E501

    action_list: Optional[List[Action]] = Field(
        default=None,
        description="An ordered list of Actions to run on the product",
        alias="actionList",
    )
    scene_list: Optional[List[StrictStr]] = Field(
        default=None, description="A list of scenes", alias="sceneList"
    )
    disabled: Optional[StrictBool] = None
    dynamic_list: Optional[StrictStr] = Field(
        default=None,
        description="Let mozart create a dynamic list. This list will be attached as children to the menu item. If dynamicList is set it's not possible to change or manipulate any of the children because mozart can alter them at any given time ",
        alias="dynamicList",
    )
    first_child_menu_item_id: Optional[StrictStr] = Field(
        default=None,
        description="ID of the first child menu item",
        alias="firstChildMenuItemId",
    )
    label: Optional[StrictStr] = Field(
        default=None,
        description="Alternative label, if omitted mozart will try its best",
    )
    next_sibling_menu_item_id: Optional[StrictStr] = Field(
        default=None,
        description="ID of the next sibling menu item",
        alias="nextSiblingMenuItemId",
    )
    parent_menu_item_id: Optional[StrictStr] = Field(
        default=None, description="ID of the parent menu item", alias="parentMenuItemId"
    )
    __properties: ClassVar[List[str]] = [
        "actionList",
        "sceneList",
        "disabled",
        "dynamicList",
        "firstChildMenuItemId",
        "label",
        "nextSiblingMenuItemId",
        "parentMenuItemId",
    ]

    @field_validator("dynamic_list")
    def dynamic_list_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(["none", "radioFavorites"]):
            raise ValueError("must be one of enum values ('none', 'radioFavorites')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RemoteMenuItemProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in action_list (list)
        _items = []
        if self.action_list:
            for _item in self.action_list:
                if _item:
                    _items.append(_item.to_dict())
            _dict["actionList"] = _items
        # set to None if disabled (nullable) is None
        # and model_fields_set contains the field
        if self.disabled is None and "disabled" in self.model_fields_set:
            _dict["disabled"] = None

        # set to None if dynamic_list (nullable) is None
        # and model_fields_set contains the field
        if self.dynamic_list is None and "dynamic_list" in self.model_fields_set:
            _dict["dynamicList"] = None

        # set to None if first_child_menu_item_id (nullable) is None
        # and model_fields_set contains the field
        if (
            self.first_child_menu_item_id is None
            and "first_child_menu_item_id" in self.model_fields_set
        ):
            _dict["firstChildMenuItemId"] = None

        # set to None if label (nullable) is None
        # and model_fields_set contains the field
        if self.label is None and "label" in self.model_fields_set:
            _dict["label"] = None

        # set to None if next_sibling_menu_item_id (nullable) is None
        # and model_fields_set contains the field
        if (
            self.next_sibling_menu_item_id is None
            and "next_sibling_menu_item_id" in self.model_fields_set
        ):
            _dict["nextSiblingMenuItemId"] = None

        # set to None if parent_menu_item_id (nullable) is None
        # and model_fields_set contains the field
        if (
            self.parent_menu_item_id is None
            and "parent_menu_item_id" in self.model_fields_set
        ):
            _dict["parentMenuItemId"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RemoteMenuItemProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "actionList": (
                    [Action.from_dict(_item) for _item in obj["actionList"]]
                    if obj.get("actionList") is not None
                    else None
                ),
                "sceneList": obj.get("sceneList"),
                "disabled": obj.get("disabled"),
                "dynamicList": obj.get("dynamicList"),
                "firstChildMenuItemId": obj.get("firstChildMenuItemId"),
                "label": obj.get("label"),
                "nextSiblingMenuItemId": obj.get("nextSiblingMenuItemId"),
                "parentMenuItemId": obj.get("parentMenuItemId"),
            }
        )
        return _obj
