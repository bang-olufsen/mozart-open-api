# coding: utf-8

"""
    Mozart platform API

    API for interacting with the Mozart platform.

    The version of the OpenAPI document: 0.2.0
    Contact: support@bang-olufsen.dk
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional

try:
    from pydantic.v1 import BaseModel, Field, StrictInt, StrictStr, conlist, validator
except ImportError:
    from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, validator

from mozart_api.models.art import Art
from mozart_api.models.beolink_leader import BeolinkLeader


class PlaybackContentMetadata(BaseModel):
    """
    PlaybackContentMetadata
    """

    album_name: Optional[StrictStr] = Field(default=None, alias="albumName")
    art: Optional[conlist(Art)] = None
    artist_name: Optional[StrictStr] = Field(default=None, alias="artistName")
    bitdepth: Optional[StrictInt] = None
    bitrate: Optional[StrictInt] = None
    container_name: Optional[StrictStr] = Field(default=None, alias="containerName")
    encoding: Optional[StrictStr] = None
    genre: Optional[StrictStr] = None
    id: Optional[StrictInt] = None
    input_channel_processing: Optional[StrictStr] = Field(
        default=None,
        alias="inputChannelProcessing",
        description="Input processing/decoding on top of the base codec indicated in encoding. E.g. Dolby Atmos on top of Dolby TrueHD or Dolby Surround on top of PCM. For Dolby, this value has priority over encoding, meaning that if inputChannelProcessing has a value, it must be indicated in the app, and optionally the encoding value can be indicated as well. If inputChannelProcessing does not have value the encoding value must be indicated. ",
    )
    input_channels: Optional[StrictStr] = Field(
        default=None, alias="inputChannels", description="e.g. 5.1"
    )
    organization: Optional[StrictStr] = Field(
        default=None,
        description='This can be filled by gstreamer\'s GST_TAG_ORGANIZATION. Mozart can also fill this with netradio station name like "P3" and TV content like "Netflix". This is needed so it\'s possible to show who the provider is for the playing audio track/content. ',
    )
    output_channel_processing: Optional[StrictStr] = Field(
        default=None, alias="outputChannelProcessing", description="e.g. downmix"
    )
    output_channels: Optional[StrictStr] = Field(
        default=None, alias="outputChannels", description="e.g. 7.1"
    )
    queue_id: Optional[StrictStr] = Field(default=None, alias="queueId")
    remote_leader: Optional[BeolinkLeader] = Field(default=None, alias="remoteLeader")
    remote_source: Optional[StrictStr] = Field(default=None, alias="remoteSource")
    samplerate: Optional[StrictInt] = None
    source: Optional[StrictStr] = None
    source_internal_id: Optional[StrictStr] = Field(
        default=None, alias="sourceInternalId"
    )
    title: Optional[StrictStr] = None
    total_duration: Optional[StrictInt] = Field(
        default=None,
        alias="totalDuration",
        description="to be removed once all devices and apps are updated",
    )
    total_duration_seconds: Optional[StrictInt] = Field(
        default=None, alias="totalDurationSeconds"
    )
    track: Optional[StrictInt] = None
    track_count: Optional[StrictInt] = Field(default=None, alias="trackCount")
    uri: Optional[StrictStr] = None
    __properties = [
        "albumName",
        "art",
        "artistName",
        "bitdepth",
        "bitrate",
        "containerName",
        "encoding",
        "genre",
        "id",
        "inputChannelProcessing",
        "inputChannels",
        "organization",
        "outputChannelProcessing",
        "outputChannels",
        "queueId",
        "remoteLeader",
        "remoteSource",
        "samplerate",
        "source",
        "sourceInternalId",
        "title",
        "totalDuration",
        "totalDurationSeconds",
        "track",
        "trackCount",
        "uri",
    ]

    @validator("encoding")
    def encoding_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in (
            "pcm",
            "wav",
            "mp3",
            "oggvorbis",
            "aac",
            "flac",
            "sbc",
            "alac",
            "opus",
            "DolbyDigital",
            "DolbyDigitalPlus",
            "DolbyTrueHD",
            "unknown",
        ):
            raise ValueError(
                "must be one of enum values ('pcm', 'wav', 'mp3', 'oggvorbis', 'aac', 'flac', 'sbc', 'alac', 'opus', 'DolbyDigital', 'DolbyDigitalPlus', 'DolbyTrueHD', 'unknown')"
            )
        return value

    @validator("input_channel_processing")
    def input_channel_processing_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ("dolbySurround", "dolbyAtmos"):
            raise ValueError(
                "must be one of enum values ('dolbySurround', 'dolbyAtmos')"
            )
        return value

    @validator("output_channel_processing")
    def output_channel_processing_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ("Direct", "Downmix", "TrueImage"):
            raise ValueError(
                "must be one of enum values ('Direct', 'Downmix', 'TrueImage')"
            )
        return value

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PlaybackContentMetadata:
        """Create an instance of PlaybackContentMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in art (list)
        _items = []
        if self.art:
            for _item in self.art:
                if _item:
                    _items.append(_item.to_dict())
            _dict["art"] = _items
        # override the default output from pydantic by calling `to_dict()` of remote_leader
        if self.remote_leader:
            _dict["remoteLeader"] = self.remote_leader.to_dict()
        # set to None if input_channel_processing (nullable) is None
        # and __fields_set__ contains the field
        if (
            self.input_channel_processing is None
            and "input_channel_processing" in self.__fields_set__
        ):
            _dict["inputChannelProcessing"] = None

        # set to None if input_channels (nullable) is None
        # and __fields_set__ contains the field
        if self.input_channels is None and "input_channels" in self.__fields_set__:
            _dict["inputChannels"] = None

        # set to None if output_channel_processing (nullable) is None
        # and __fields_set__ contains the field
        if (
            self.output_channel_processing is None
            and "output_channel_processing" in self.__fields_set__
        ):
            _dict["outputChannelProcessing"] = None

        # set to None if output_channels (nullable) is None
        # and __fields_set__ contains the field
        if self.output_channels is None and "output_channels" in self.__fields_set__:
            _dict["outputChannels"] = None

        # set to None if remote_source (nullable) is None
        # and __fields_set__ contains the field
        if self.remote_source is None and "remote_source" in self.__fields_set__:
            _dict["remoteSource"] = None

        # set to None if total_duration (nullable) is None
        # and __fields_set__ contains the field
        if self.total_duration is None and "total_duration" in self.__fields_set__:
            _dict["totalDuration"] = None

        # set to None if total_duration_seconds (nullable) is None
        # and __fields_set__ contains the field
        if (
            self.total_duration_seconds is None
            and "total_duration_seconds" in self.__fields_set__
        ):
            _dict["totalDurationSeconds"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PlaybackContentMetadata:
        """Create an instance of PlaybackContentMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PlaybackContentMetadata.parse_obj(obj)

        _obj = PlaybackContentMetadata.parse_obj(
            {
                "album_name": obj.get("albumName"),
                "art": (
                    [Art.from_dict(_item) for _item in obj.get("art")]
                    if obj.get("art") is not None
                    else None
                ),
                "artist_name": obj.get("artistName"),
                "bitdepth": obj.get("bitdepth"),
                "bitrate": obj.get("bitrate"),
                "container_name": obj.get("containerName"),
                "encoding": obj.get("encoding"),
                "genre": obj.get("genre"),
                "id": obj.get("id"),
                "input_channel_processing": obj.get("inputChannelProcessing"),
                "input_channels": obj.get("inputChannels"),
                "organization": obj.get("organization"),
                "output_channel_processing": obj.get("outputChannelProcessing"),
                "output_channels": obj.get("outputChannels"),
                "queue_id": obj.get("queueId"),
                "remote_leader": (
                    BeolinkLeader.from_dict(obj.get("remoteLeader"))
                    if obj.get("remoteLeader") is not None
                    else None
                ),
                "remote_source": obj.get("remoteSource"),
                "samplerate": obj.get("samplerate"),
                "source": obj.get("source"),
                "source_internal_id": obj.get("sourceInternalId"),
                "title": obj.get("title"),
                "total_duration": obj.get("totalDuration"),
                "total_duration_seconds": obj.get("totalDurationSeconds"),
                "track": obj.get("track"),
                "track_count": obj.get("trackCount"),
                "uri": obj.get("uri"),
            }
        )
        return _obj
